{"version":3,"file":"perspectives-pageworker.js","sources":["../src/perspectives-pageworker.js"],"sourcesContent":["// BEGIN LICENSE\n// Perspectives Distributed Runtime\n// Copyright (C) 2019 Joop Ringelberg (joopringelberg@perspect.it), Cor Baars\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n//\n// Full text of this license can be found in the LICENSE file in the projects root.\n// END LICENSE\n\n// Notice that even though the method name \"postMessage\" equals that of Window.postMessage, here we deal\n// with MessagePort.postMessage and ServiceWorker.postMessage. These methods have a different interface.\n// See:\n// https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage\n// https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker/postMessage\n// https://developer.mozilla.org/en-US/docs/Web/API/MessagePort/postMessage\n\n////////////////////////////////////////////////////////////////////////////////\n//// STORING PORTS SENT BY CLIENT PAGES\n////////////////////////////////////////////////////////////////////////////////\n// An array of MessageChannel ports.\nconst channels = {};\nlet channelIndex = 1;\n\n////////////////////////////////////////////////////////////////////////////////\n//// PORT TO PAGE THAT HOSTS PDR\n//// RECEIVE PORTS FROM CLIENTS WHEN RUN IN THE MAIN PAGE, RELAYED THROUGH A SERVICE WORKER\n//// This function is passed on by the client in the call configurePDRProxy({pageHostingPDRPort: pageHostingPDRPort})\n//// This function returns a MessagePort as documented here: https://developer.mozilla.org/en-US/docs/Web/API/MessagePort.\n////////////////////////////////////////////////////////////////////////////////\nexport default function pageHostingPDRPort(pdr) {\n  // Create a channel.\n  const channel = new MessageChannel();\n  let weHost = false;\n\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.register(\n      'perspectives-pagedispatcher.js',\n      {\n        scope: './'\n      }).then(function (registration) {\n        var serviceWorker;\n        if (registration.installing) {\n          serviceWorker = registration.installing;\n        } else if (registration.waiting) {\n          serviceWorker = registration.waiting;\n        } else if (registration.active) {\n          serviceWorker = registration.active;\n        }\n        if (serviceWorker) {\n          // Listen to messages coming in from the serviceWorker. The serviceWorker is the central hub that passes messages\n          // between the page hosting the PDR and the other pages.\n          // Notice that all pages that are not the first will never handle a message.\n          // Notice that this handler is on the ServiceWorkerContainer of EACH PAGE; NOT IN THE SERVICEWORKER ITSELF!\n\n          // Notice that this listener is just used to shuffle ports between pages.\n          // We establish a connection between the page that hosts the PDR and the page that\n          // wants to use the PDR. That connection is a 'channel'.\n          // It consists of two ports. One port is sent by the page that wants to use de PDR.\n          // It is received and used by the page that hosts the PDR.\n          // The other port is used by the page that wants to use the PDR.\n          // Corrolary: this listener has nothing to do with Perspectives calls that are passed \n          // from client pages to the PDR!\n          navigator.serviceWorker.addEventListener('message', function (event) {\n            switch (event.data.messageType) {\n              case \"youHost\":\n                const hostingPage = event.data.port;\n                // This message only arrives to the very first page visiting InPlace.\n                // This page must host the PDR.\n                weHost = true;\n                // We've sent ourselves a port.\n                channels[channelIndex] = event.data.port;\n                // Return the channelIndex.\n                channels[channelIndex].postMessage({ responseType: \"WorkerResponse\", serviceWorkerMessage: \"channelId\", channelId: 1000000 * channelIndex });\n                // start listening to the new channel, handle requests.\n                // The page that has sent the port will send WorkerResponse messages and API calls\n                hostingPage.onmessage = request => pdr.handleClientRequest(pdr, channels, request, 1000000 * channelIndex);\n                // increment the index so we're ready for the next page that connects.\n                channelIndex = channelIndex + 1;\n                break;\n              case \"relayPort\":\n                // If we are the host, save the port; otherwise ignore.\n                if (weHost) {\n                  // Notice how this section is exactly the same as the one in the onconnect handler of the SharedWorker.\n                  const connectionToAPage = event.data.port;\n                  // the new client (page) sends a port. This is a MessagePort.\n                  channels[channelIndex] = event.data.port;\n                  // Return the channelIndex.\n                  channels[channelIndex].postMessage({ responseType: \"WorkerResponse\", serviceWorkerMessage: \"channelId\", channelId: 1000000 * channelIndex });\n                  // start listening to the new channel, handle requests.\n                  connectionToAPage.onmessage = request => pdr.handleClientRequest(pdr, channels, request, 1000000 * channelIndex);\n                  // increment the index so we're ready for the next page that connects.\n                  channelIndex = channelIndex + 1;\n                }\n                break;\n            }\n          });\n          if (navigator.serviceWorker.controller) {\n            console.log(\"navigator heeft controler direct na registreren - deze pagina stuurt relayport nu.\")\n            // This call transfers port2 of the channel to the serviceWorker perspectives-pagedispatcher.js.\n            // The serviceWorker will transfer it to the page hosting the PDR.\n            // NOTICE that by providing the port as a second argument, we transfer ownership of the port to the serviceWorker.\n            navigator.serviceWorker.controller.postMessage({ messageType: \"relayPort\", port: channel.port2 }, [channel.port2]);\n          }\n        }\n        else {\n          console.log(\"Could not get serviceWorker from registration for an unknown reason.\");\n        }\n        // Listen to the controllerchange event. This is fired when the service worker takes control of the page.\n        // For the first page that registers, the case above (if (navigator.serviceWorker.controller)) will be false.\n        // Hence, the first page would never send a \"relayPort\" message to the service worker.\n        // Also, when a new version of the service worker is installed, the controllerchange event is fired, too.\n        navigator.serviceWorker.addEventListener(\"controllerchange\", () => {\n          // Send the port to the serviceWorker, to relay it to the page hosting the PDR.\n          // Only the serviceworker knows how many clients it has. If there is but one, it will immediately\n          // return a \"youhost\" message to this listener, which will set 'wehost' to true. \n          // See: https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker/postMessage\n          console.log(\"Controller change. Deze pagina heeft de PDR, of er is een nieuwe versie van 'perspectives-pagedispachter.js'. Hij stuurt relayport nu.\")\n          navigator.serviceWorker.controller.postMessage({ messageType: \"relayPort\", port: channel.port2 }, [channel.port2]);\n        });\n\n      }).catch(function (error) {\n        // Something went wrong during registration. The service-worker.js file\n        // might be unavailable or contain a syntax error.\n        console.log(error);\n      });\n  }\n  else {\n    console.log(\"This browser does not support service workers.\");\n  }\n  // Use port1 in the SharedWorkerChannel.\n  return channel.port1;\n}\n"],"names":["channels","channelIndex","pageHostingPDRPort","pdr","channel","MessageChannel","weHost","navigator","serviceWorker","register","scope","then","registration","installing","waiting","active","addEventListener","event","data","messageType","hostingPage","port","postMessage","responseType","serviceWorkerMessage","channelId","onmessage","request","handleClientRequest","connectionToAPage","controller","console","log","port2","error","port1"],"mappings":"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"}